'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var getCalculatedOffset = require('./utils/getCalculatedOffset/getCalculatedOffset.cjs');
var groupWalletOptions = require('./utils/groupWalletOptions/groupWalletOptions.cjs');
var filterConnectedWallets = require('./utils/filterConnectedWallets/filterConnectedWallets.cjs');

const PRIORITY_WALLET_LIST = [
    'metamask',
    'coinbase',
    'walletconnect',
    'phantom',
    'argentx',
    'myalgo',
    'blocto',
    'solflare',
    'braavos',
    'trust',
    'rainbow',
    'dapper',
    'glow',
    'lilico',
];
const SIGN_IN_WITH_EMAIL_WALLET_NAME = 'Sign In With Email';
const sortedInputList = (inputList, recommendedWalletKeys) => {
    // Input is the unordered list of wallets we support
    const unsortedRecommendedWallets = [];
    const unsortedPriorityWallets = [];
    const unsortedOtherWallets = [];
    inputList.forEach((wallet) => {
        const isRecommendedWallet = recommendedWalletKeys.includes(wallet.key);
        if (isRecommendedWallet) {
            unsortedRecommendedWallets.push(wallet);
        }
        else if (PRIORITY_WALLET_LIST.includes(wallet.key) &&
            !isRecommendedWallet) {
            unsortedPriorityWallets.push(wallet);
        }
        else {
            unsortedOtherWallets.push(wallet);
        }
    });
    const sortedPriorityWallets = unsortedPriorityWallets
        .slice()
        .sort((a, b) => PRIORITY_WALLET_LIST.indexOf(a.key) -
        PRIORITY_WALLET_LIST.indexOf(b.key));
    const sortedRecommendedWallets = unsortedRecommendedWallets
        .slice()
        .sort((a, b) => recommendedWalletKeys.indexOf(a.key) -
        recommendedWalletKeys.indexOf(b.key));
    return [
        ...sortedRecommendedWallets,
        ...sortedPriorityWallets,
        ...unsortedOtherWallets,
    ];
};
const walletListBuilder = ({ authMode, connectedWallets, multiWallet, numberOfWalletsToShow, inputList, isWalletConnectList, lastUsedWalletKey, signWithEmailWalletName, searchFilter, walletsFilter, loginWithEmail, groupWallets, walletBook, showMoreWalletsWithFilter, recommendedWallets, }) => {
    let walletList = inputList;
    if (isWalletConnectList) {
        walletList = inputList.filter((wallet) => wallet.walletConnector.isWalletConnect &&
            wallet.key !== 'walletconnect');
    }
    if (authMode === 'connect-only' && multiWallet) {
        walletList = filterConnectedWallets.filterConnectedWallets({
            connectedWallets,
            walletOptions: walletList,
        });
    }
    let lastUsedWallet;
    const hasWalletFilter = Boolean(walletsFilter);
    const signWithEmailWallet = getSignWithEmailWallet(signWithEmailWalletName, walletList);
    const recommendedWalletsList = [];
    const installedWallets = [];
    const otherWallets = [];
    const recommendedWalletKeys = Array.from(new Set((recommendedWallets || []).map((w) => w.walletKey)));
    const orderedInputList = orderAndFilterList(walletList, walletsFilter, isWalletConnectList, recommendedWalletKeys);
    orderedInputList.forEach((wallet) => {
        const isRecommendedWallet = recommendedWalletKeys === null || recommendedWalletKeys === void 0 ? void 0 : recommendedWalletKeys.includes(wallet.key);
        if (walletConnectorCore.isEmbeddedConnector(wallet.walletConnector)) {
            return;
        }
        else if (isRecommendedWallet) {
            recommendedWalletsList.push(wallet);
        }
        else if (lastUsedWalletKey === wallet.key) {
            lastUsedWallet = wallet;
        }
        else if (wallet.isInstalledOnBrowser) {
            installedWallets.push(wallet);
        }
        else {
            otherWallets.push(wallet);
        }
    });
    const firstPriorityWallets = [
        ...(signWithEmailWallet ? [signWithEmailWallet] : []),
        ...(lastUsedWallet ? [lastUsedWallet] : []),
    ];
    const walletsList = [
        ...recommendedWalletsList,
        ...firstPriorityWallets,
        ...installedWallets,
        ...otherWallets,
    ];
    const finalizedWalletList = groupWallets
        ? groupWalletOptions.groupWalletOptions(walletBook, walletsList)
        : walletsList;
    const updatedNumberOfWalletsToShow = showMoreWalletsWithFilter && hasWalletFilter
        ? calculateWithFilterNumberOfWalletsToShow(orderedInputList, firstPriorityWallets.concat(installedWallets), numberOfWalletsToShow)
        : numberOfWalletsToShow;
    return {
        numberOfWallets: walletsList.length,
        walletsList: listToDisplay(finalizedWalletList, searchFilter, isWalletConnectList, updatedNumberOfWalletsToShow, hasWalletFilter, loginWithEmail),
    };
};
// We want to show the full list of wallets when we render the wallet connect list even
// if a filter was applied to the main page
const orderAndFilterList = (walletList, walletsFilter, isWalletConnectList, recommendedWalletKeys) => {
    const sortedWalletList = sortedInputList(walletList, recommendedWalletKeys);
    if (!isWalletConnectList && walletsFilter) {
        return walletsFilter(sortedWalletList);
    }
    else {
        return sortedWalletList;
    }
};
const applySearchFilterToWalletOptionList = (rawSearchFilter, walletOptionList) => {
    const searchFilter = rawSearchFilter.trim().toLowerCase();
    return walletOptionList.filter((walletOption) => {
        var _a;
        return walletOption.name.trim().toLowerCase().includes(searchFilter) ||
            (
            // Validate nested wallets
            (_a = walletOption.groupedWallets) === null || _a === void 0 ? void 0 : _a.some((nestedWalletOption) => nestedWalletOption.name.trim().toLowerCase().includes(searchFilter)));
    });
};
const listToDisplay = (finalizedList, searchFilter, isWalletConnectList, numberOfWalletsToShow, hasWalletFilter, loginWithEmail) => {
    if (searchFilter) {
        return applySearchFilterToWalletOptionList(searchFilter, finalizedList);
    }
    else if (isWalletConnectList) {
        return finalizedList;
    }
    else if (loginWithEmail) {
        return finalizedList.slice(0, numberOfWalletsToShow);
    }
    else {
        const list = finalizedList.map((wallet) => wallet.name.toLowerCase());
        const offset = getCalculatedOffset.getCalculatedOffset({
            defaultOffset: numberOfWalletsToShow,
            hasWalletFilter,
            list,
            priorityList: PRIORITY_WALLET_LIST,
        });
        return finalizedList.slice(0, offset);
    }
};
/**
 * When a filter is applied we would like to show the installed + last used wallets
 * in addition to the wallets that the filter has specified.
 * This calculation adds an offset to numberOfWalletsToShow so we will show the
 * intended wallets + installed and last used.
 *
 * For example:
 * we want to show 4 wallets: ['metamask', 'rainbow', 'walletconnect', 'coinbase']
 * and someone is using brave with installed phantom he should see
 * [ 'brave injected', phantom ,'metamask', 'rainbow', 'walletconnect', 'coinbase',]
 *
 * note â€” this should only apply to the WalletList view!
 */
const calculateWithFilterNumberOfWalletsToShow = (allWalletsOrdered, installedOrUsedWallets, numberOfWalletsToShow) => {
    const filteredWallets = allWalletsOrdered.slice(0, numberOfWalletsToShow);
    const offset = installedOrUsedWallets.filter((wallet) => !filteredWallets.includes(wallet)).length;
    return numberOfWalletsToShow + offset;
};
const getSignWithEmailWallet = (signWithEmailWalletName, inputList) => {
    let walletOverride;
    if (signWithEmailWalletName) {
        const walletToReplicate = inputList.find((wallet) => wallet.name === signWithEmailWalletName &&
            wallet.walletConnector.canConnectViaCustodialService);
        if (walletToReplicate) {
            walletOverride = Object.assign({}, walletToReplicate);
            walletOverride.name = SIGN_IN_WITH_EMAIL_WALLET_NAME;
        }
    }
    return walletOverride;
};

exports.PRIORITY_WALLET_LIST = PRIORITY_WALLET_LIST;
exports.SIGN_IN_WITH_EMAIL_WALLET_NAME = SIGN_IN_WITH_EMAIL_WALLET_NAME;
exports.walletListBuilder = walletListBuilder;
