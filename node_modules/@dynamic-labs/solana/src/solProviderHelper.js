import { __awaiter } from '../_virtual/_tslib.js';
import { getProvidersFromWindow, bufferToBase64 } from '@dynamic-labs/utils';
import { ProviderLookup } from '@dynamic-labs/wallet-connector-core';
import { isSignedMessage } from './utils/isSignedMessage.js';

class SolProviderHelper {
    constructor(wallet) {
        this.wallet = wallet;
    }
    getInjectedConfig() {
        if (!this.wallet || !this.wallet.injectedConfig)
            return;
        const { injectedConfig } = this.wallet;
        return injectedConfig.find((c) => c.chain === 'sol');
    }
    getInstalledProvider() {
        const config = this.getInjectedConfig();
        if (!config || !config.extensionLocators) {
            return undefined;
        }
        return this.installedProviderLookup(config.extensionLocators);
    }
    installedProviders() {
        const config = this.getInjectedConfig();
        if (!config)
            return [];
        const providers = [];
        if (config.windowLocations) {
            for (const windowLocation of config.windowLocations) {
                const foundProviders = getProvidersFromWindow(windowLocation);
                if (foundProviders && foundProviders.length)
                    providers.push(...foundProviders);
            }
        }
        if (window.solana) {
            if (!window.solana.providers) {
                providers.push(window.solana);
            }
            else {
                window.solana.providers.forEach((provider) => providers.push(provider));
            }
        }
        return providers;
    }
    installedProviderLookup(providerFlags) {
        const allInstalledProviders = this.installedProviders();
        // If no provider flags are provided, return the first provider
        // This is required for the coinbaseSolana window provider which has no locators
        if (providerFlags.length === 0)
            return allInstalledProviders[0];
        return ProviderLookup(allInstalledProviders, providerFlags);
    }
    findProvider() {
        return this.getInstalledProvider();
    }
    isInstalledHelper() {
        return this.findProvider() !== undefined;
    }
    getAddress() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.findProvider();
            if (!provider) {
                return undefined;
            }
            if (!provider.isConnected) {
                yield provider.connect();
            }
            return (_a = provider.publicKey) === null || _a === void 0 ? void 0 : _a.toString();
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.findProvider();
            if (!provider)
                return undefined;
            try {
                if (!provider.isConnected) {
                    yield provider.connect();
                }
                return provider;
            }
            catch (err) {
                return undefined;
            }
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletAddress = yield this.getAddress();
            if (!walletAddress)
                return undefined;
            const provider = this.findProvider();
            if (!provider)
                return undefined;
            if (!provider.isConnected) {
                yield provider.connect();
            }
            const encodedMessage = new TextEncoder().encode(messageToSign);
            const signedMessage = yield provider.signMessage(encodedMessage, 'utf8');
            if (!signedMessage)
                return undefined;
            return bufferToBase64(isSignedMessage(signedMessage) ? signedMessage.signature : signedMessage);
        });
    }
    handleAccountChange(walletConnector, web3Provider, address) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!address) {
                yield (web3Provider === null || web3Provider === void 0 ? void 0 : web3Provider.connect());
                if ((_a = web3Provider === null || web3Provider === void 0 ? void 0 : web3Provider.publicKey) === null || _a === void 0 ? void 0 : _a.toString()) {
                    walletConnector.emit('accountChange', {
                        accounts: [web3Provider.publicKey.toString()],
                    });
                }
                return;
            }
            if (address.toString()) {
                walletConnector.emit('accountChange', { accounts: [address.toString()] });
            }
        });
    }
    _setupEventListeners(walletConnector) {
        const provider = this.findProvider();
        provider === null || provider === void 0 ? void 0 : provider.on('accountChanged', (publicKey) => this.handleAccountChange(walletConnector, provider, publicKey));
        provider === null || provider === void 0 ? void 0 : provider.on('disconnect', () => walletConnector.emit('disconnect'));
    }
    _teardownEventListeners() {
        const provider = this.findProvider();
        if (!provider)
            return;
        provider.removeAllListeners();
    }
    getConnectedAccounts() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.findProvider();
            if (!provider)
                return [];
            let connectionResult;
            try {
                if (!provider.isConnected) {
                    connectionResult = yield provider.connect({ onlyIfTrusted: true });
                }
            }
            catch (e) {
                return [];
            }
            const address = connectionResult === null || connectionResult === void 0 ? void 0 : connectionResult.address;
            const publicKey = (_a = connectionResult === null || connectionResult === void 0 ? void 0 : connectionResult.publicKey) !== null && _a !== void 0 ? _a : (_b = provider.publicKey) === null || _b === void 0 ? void 0 : _b.toString();
            if (address)
                return [address];
            else if (publicKey)
                return [publicKey === null || publicKey === void 0 ? void 0 : publicKey.toString()];
            else
                return [];
        });
    }
}

export { SolProviderHelper };
