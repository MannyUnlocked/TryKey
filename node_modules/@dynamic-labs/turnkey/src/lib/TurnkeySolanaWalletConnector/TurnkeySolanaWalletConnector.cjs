'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var web3_js = require('@solana/web3.js');
var webauthnStamper = require('@turnkey/webauthn-stamper');
var http = require('@turnkey/http');
var solana = require('@turnkey/solana');
var iframeStamper = require('@turnkey/iframe-stamper');
var rpcProviderSolana = require('@dynamic-labs/rpc-provider-solana');
var utils = require('@dynamic-labs/utils');
var solanaUtils = require('@dynamic-labs/solana-utils');
var TurnkeyWalletConnectorBase = require('../TurnkeyWalletConnectorBase/TurnkeyWalletConnectorBase.cjs');
var findTurnkeyVerifiedCredential = require('../utils/findTurnkeyVerifiedCredential/findTurnkeyVerifiedCredential.cjs');
require('../utils/convertAttestationTransports/convertAttestationTransports.cjs');
var getTLD = require('../utils/getTLD/getTLD.cjs');
var createSolanaConnection = require('../utils/createSolanaConnection/createSolanaConnection.cjs');
var transactionDecoder = require('../utils/transactionDecoder/transactionDecoder.cjs');
var constants = require('../constants.cjs');

class TurnkeySolanaWalletConnector extends TurnkeyWalletConnectorBase.TurnkeyWalletConnectorBase {
    constructor(nameAndKey, props) {
        var _a;
        super(nameAndKey, props);
        // Public fields
        this.connectedChain = 'SOL';
        this.supportedChains = ['SOL'];
        this.verifiedCredentialChain = 'solana';
        this.solNetworks = props.solNetworks;
        this.walletUiUtils = props.walletUiUtils;
        this._turnkeyAccount = undefined;
        this._connectionClient = undefined;
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerSolanaProviders();
        this.__turnkeyClient = this.getTurnkeyClient();
    }
    getRpcUrl() {
        var _a;
        const [network] = this.solNetworks;
        if (!network) {
            throw new utils.DynamicError('No enabled networks');
        }
        return ((_a = network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || network.rpcUrls[0];
    }
    getConnection(commitmentOrConfig) {
        if (!this._connectionClient) {
            const rpcUrl = this.getRpcUrl();
            if (!rpcUrl)
                throw new utils.DynamicError('No rpcUrl');
            this._connectionClient = createSolanaConnection.createSolanaConnection(rpcUrl, commitmentOrConfig);
        }
        return this._connectionClient;
    }
    getWalletClient() {
        return this.getConnection();
    }
    getNetwork() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const connection = this.getConnection();
            let genesisHash = yield connection.getGenesisHash();
            genesisHash = genesisHash.substring(0, 32);
            // see: https://github.com/ChainAgnostic/namespaces/blob/main/solana/caip2.md
            if (genesisHash === '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp') {
                return 'mainnet';
            }
            else if (genesisHash === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1') {
                return 'devnet';
            }
            else {
                return 'testnet';
            }
        });
    }
    getPublicClient() {
        var _a, _b;
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.solNetworks.length === 0)
                return;
            const configurations = {
                cosmos: [],
                evm: undefined,
                solana: this.solNetworks,
                starknet: undefined,
            };
            return (_b = (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.getSolanaRpcProviderByChainId(configurations, '101')) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    supportsNetworkSwitching() {
        return false;
    }
    setVerifiedCredentials(verifiedCredentials) {
        const turnkeyVerifiedCredential = findTurnkeyVerifiedCredential.findTurnkeyVerifiedCredential(verifiedCredentials, rpcProviderSolana.ProviderChain.SOLANA);
        const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredential) !==
            JSON.stringify(turnkeyVerifiedCredential);
        if (!didTurnkeyVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = turnkeyVerifiedCredential;
        this.refreshTurnkeyAccount();
    }
    getAccount() {
        return this.turnkeyAddress;
    }
    refreshTurnkeyAccount() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            this._turnkeyAccount = undefined;
            return this.getTurnkeyAccount();
        });
    }
    getTurnkeyClient() {
        var _a;
        let rpId = getTLD.getTLD();
        if (!rpId) {
            rpId = window.location.hostname;
        }
        const stamper = new webauthnStamper.WebauthnStamper({
            rpId,
        });
        this.__turnkeyClient =
            (_a = this.getAuthenticatorHandler().client) !== null && _a !== void 0 ? _a : new http.TurnkeyClient({
                baseUrl: constants.TURNKEY_API_BASE_URL,
            }, stamper);
        return this.__turnkeyClient;
    }
    createTurnkeyAccount({ organizationId, }) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const turnkeyClient = this.getTurnkeyClient();
            const signer = new solana.TurnkeySigner({ client: turnkeyClient, organizationId });
            return signer;
        });
    }
    getTurnkeyAccount() {
        var _a, _b, _c, _d;
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._turnkeyAccount &&
                ((this.getAuthenticatorHandler().recoveryType === 'passkey' &&
                    ((_a = this.__turnkeyClient) === null || _a === void 0 ? void 0 : _a.stamper) instanceof webauthnStamper.WebauthnStamper) ||
                    (this.getAuthenticatorHandler().recoveryType === 'email' &&
                        ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof iframeStamper.IframeStamper)) &&
                this.__turnkeyClient === this.getAuthenticatorHandler().client) {
                return this._turnkeyAccount;
            }
            const { turnkeySubOrganizationId } = (_c = this.walletProperties) !== null && _c !== void 0 ? _c : {};
            const { address } = (_d = this.verifiedCredential) !== null && _d !== void 0 ? _d : {};
            if (!turnkeySubOrganizationId || !address) {
                return;
            }
            this._turnkeyAccount = yield this.createTurnkeyAccount({
                organizationId: turnkeySubOrganizationId,
            });
            return this._turnkeyAccount;
        });
    }
    getSigner() {
        return this.getTurnkeyAccount();
    }
    getBalance() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const address = this.getAccount();
            if (!address) {
                return undefined;
            }
            const connectionClient = this.getConnection();
            const publicKey = new web3_js.PublicKey(address);
            const balance = yield connectionClient.getBalance(publicKey);
            const solBalance = this.lamportsToSol(balance);
            return solBalance.toString();
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress) {
                throw new utils.DynamicError('No turnkey account');
            }
            const address = this.turnkeyAddress;
            const signedMessage = yield this.walletUiUtils.signMessage({
                handler: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const enc = new TextEncoder();
                    const encodedMessage = enc.encode(messageToSign);
                    const signedMessageRaw = yield ((_a = (yield this.getTurnkeyAccount())) === null || _a === void 0 ? void 0 : _a.signMessage(encodedMessage, address));
                    return utils.bufferToBase64(signedMessageRaw || Buffer.from([]));
                }),
                message: messageToSign,
            });
            return signedMessage;
        });
    }
    signTransaction({ transaction, }) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const account = yield this.getTurnkeyAccount();
            const address = this.turnkeyAddress;
            if (!account || !address) {
                throw new Error('No turnkey account');
            }
            yield account.addSignature(transaction, address);
            return Buffer.from(transaction.serialize());
        });
    }
    internalSignAndSendTransaction(transaction, options) {
        var _a;
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new utils.DynamicError('Solana wallet not found');
            const currentConnection = this.getConnection('confirmed');
            const blockhash = yield currentConnection.getLatestBlockhash();
            const { recentBlockhash, feePayer } = transaction;
            if (!recentBlockhash && !feePayer) {
                transaction.recentBlockhash = blockhash.blockhash;
                transaction.feePayer = new web3_js.PublicKey(this.turnkeyAddress);
            }
            const signedTransaction = yield this.signTransaction({ transaction });
            const signature = yield currentConnection.sendRawTransaction(signedTransaction, options);
            const transactionConfirmationStrategy = {
                blockhash: blockhash.blockhash,
                lastValidBlockHeight: blockhash.lastValidBlockHeight,
                signature,
            };
            const result = yield (currentConnection === null || currentConnection === void 0 ? void 0 : currentConnection.confirmTransaction(transactionConfirmationStrategy));
            return ((_a = result === null || result === void 0 ? void 0 : result.value) === null || _a === void 0 ? void 0 : _a.err) ? JSON.stringify(result.value.err) : signature;
        });
    }
    signAndSendTransaction(transaction, options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new utils.DynamicError('Solana wallet not found');
            const transactionsData = transactionDecoder.decodeTransaction(transaction);
            if (!(transactionsData === null || transactionsData === void 0 ? void 0 : transactionsData.length)) {
                throw new utils.DynamicError('Incorrectly formatted transaction instructions');
            }
            const { to, value } = transactionDecoder.summarizeTransactionDecodedData(transactionsData);
            const uiTransaction = new solanaUtils.SolanaUiTransaction({
                connection: this.getConnection(),
                from: this.turnkeyAddress,
                onSubmit: () => _tslib.__awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(transaction, options); }),
                originalTransaction: transaction,
            });
            uiTransaction.to = to;
            uiTransaction.value = value;
            return this.walletUiUtils.sendTransaction(this, uiTransaction);
        });
    }
    sendTransaction(transaction, connection, options = {}) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new utils.DynamicError('Solana wallet not found');
            if (!transaction || !connection) {
                throw new utils.DynamicError('Transaction and connection are required');
            }
            const { signers } = options, sendOptions = _tslib.__rest(options, ["signers"]);
            if ('version' in transaction) {
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.sign(signers);
            }
            else {
                transaction.feePayer =
                    transaction.feePayer || new web3_js.PublicKey(this.turnkeyAddress);
                transaction.recentBlockhash =
                    transaction.recentBlockhash ||
                        (yield connection.getLatestBlockhash({
                            commitment: options.preflightCommitment,
                            minContextSlot: options.minContextSlot,
                        })).blockhash;
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);
            }
            sendOptions.preflightCommitment =
                sendOptions.preflightCommitment || connection.commitment;
            return this.internalSignAndSendTransaction(transaction, options);
        });
    }
    lamportsToSol(lamports) {
        return lamports / web3_js.LAMPORTS_PER_SOL;
    }
    createUiTransaction(from) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return new solanaUtils.SolanaUiTransaction({
                connection: this.getConnection(),
                from,
                onSubmit: (transaction) => _tslib.__awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(transaction); }),
            });
        });
    }
}

exports.TurnkeySolanaWalletConnector = TurnkeySolanaWalletConnector;
